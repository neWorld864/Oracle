-- DML : 데이터 조작 언어

COMMIT;

-- INSERT
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL,
                     SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)
VALUES (900, '장채현', '001111-1111111', 'jang_ch@kh.or.kr', '01012345678', 'D1', 'J7', 'S3', 
        4300000, 0.2, '200', SYSDATE, NULL, DEFAULT);

-- 방법2
INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, EMAIL, PHONE, DEPT_CODE, JOB_CODE, SAL_LEVEL,
                     SALARY, BONUS, MANAGER_ID, HIRE_DATE, ENT_DATE, ENT_YN)        
VALUES (900, '장채현', '001111-1111111', 'jang_ch@kh.or.kr', '01012345678', 'D1', 'J7', 'S3', 
        4300000, 0.2, '200', SYSDATE,  DEFAULT, NULL);
        
SELECT * FROM EMPLOYEE;

COMMIT;

CREATE TABLE EMP_01(
    EMP_ID NUMBER,
    EMP_NAME VARCHAR2(30),
    DEPT_TITLE VARCHAR2(20)
);

INSERT INTO EMP_01(
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    FROM EMPLOYEE
         LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
);

SELECT * FROM EMP_01;

-- INSERT ALL
CREATE TABLE EMP_DEPT_D1
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
    FROM EMPLOYEE
    WHERE 1 = 0; -- 구조만 따오고 싶을 때 WHERE절이 FALSE가 나오게 한다

SELECT * FROM EMP_DEPT_D1;
-- 아무 값도 나오지 않음 -> 구조만 들어감
-- WHERE 1 = 0; -> 무조건 FALSE => 아무 행도 들어가지 않게 됨

CREATE TABLE EMP_MANAGER
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID
    FROM EMPLOYEE
    WHERE 1 = 0; 

SELECT * FROM EMP_MANAGER;

-- EMP_DEPT_D1 테이블에 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해 삽입(사번, 이름, 소속부서, 입사일)
-- EMP_MANAGER 테이블에 EMPLOYEE테이블에 있는 부서코드가 D1인 직원을 조회해 삽입(사번, 이름, 관리자 사번)
INSERT INTO EMP_DEPT_D1(
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1'
);

INSERT INTO EMP_MANAGER(
    SELECT EMP_ID, EMP_NAME, MANAGER_ID
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1'
);

SELECT * FROM EMP_DEPT_D1;
SELECT * FROM EMP_MANAGER;

ROLLBACK;

INSERT ALL
INTO EMP_DEPT_D1 VALUES(EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE)
INTO EMP_MANAGER VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
    SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE, MANAGER_ID
    FROM EMPLOYEE
    WHERE DEPT_CODE = 'D1';
-- DEPT_CODE가 'D1'로 동일하기 때문에 INSERT ALL로 묶을 수  있다
    
-- EMPLOYEE 테이블의 구조를 복사하여 사번, 이름, 입사일, 급여를 기록할 수 있는 테이블 EMP_OLD와 EMP_NEW 생성
CREATE TABLE EMP_OLD(
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1 = 0
);

CREATE TABLE EMP_NEW(
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE 1 = 0
);
    
-- EMP_OLD : 2000/1/1 이전 입사
-- EMP_NEW : 2000/1/1 이후 입사

INSERT INTO EMP_OLD -- 맞는지 확인
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE HIRE_DATE < '2000/01/01';

INSERT INTO EMP_NEW
    SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
    FROM EMPLOYEE
    WHERE HIRE_DATE >= '2000/01/01';
    
INSERT ALL
    WHEN 
        HIRE_DATE < '2000/1/1'
    THEN 
        INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
    WHEN 
        HIRE_DATE >= '2000/1/1'
    THEN 
        INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

-- 방법2
INSERT ALL
    WHEN 
        HIRE_DATE < '2000/1/1'
    THEN 
        INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
    ELSE
        INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, HIRE_DATE, SALARY)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, SALARY
FROM EMPLOYEE;

SELECT * FROM EMP_OLD;
SELECT * FROM EMP_NEW;

-- UPDATE
CREATE TABLE DEPT_COPY
AS SELECT * FROM DEPARTMENT;

SELECT * FROM DEPT_COPY;

UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획팀'
WHERE DEPT_ID = 'D9';

SELECT * FROM DEPT_COPY;

COMMIT;

UPDATE DEPT_COPY
SET DEPT_TITLE = '전략기획팀';

SELECT * FROM DEPT_COPY;

ROLLBACK;

CREATE TABLE EMP_SALARY
AS SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY, BONUS
    FROM EMPLOYEE;
    
SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN('유재식', '방명수');

UPDATE EMP_SALARY
SET SALARY = (SELECT SALARY
              FROM EMP_SALARY
              WHERE EMP_NAME = '유재식'),
    BONUS = (SELECT BONUS
             FROM EMP_SALARY
             WHERE EMP_NAME = '유재식')
WHERE EMP_NAME = '방명수';
-- 방명수 사원의 SALARY과 BONUS를 유재식 사원과 같게

SELECT * FROM EMP_SALARY
WHERE EMP_NAME IN ('유재식', '노옹철', '하동운', '전형돈', '정중하');
-- 노옹철, 하동운, 전형돈, 정중하도 SALARY가 유재식과 같게 -> 다중열 다중행으로

UPDATE EMP_SALARY
SET (SALARY, BONUS) = (SELECT SALARY, BONUS
                       FROM EMP_SALARY
                       WHERE EMP_NAME = '유재식')
WHERE EMP_NAME IN ('노옹철', '하동운', '전형돈', '정중하');

--EMP_SALARY테이블에서 아시아 지역에 근무하는 직원의 보너스를 0.3으로 변경
-- 아시아에 근무하는 직원(SELECT)
SELECT EMP_ID, EMP_NAME, SALARY, BONUS, LOCAL_NAME
FROM EMP_SALARY
     JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
     JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
WHERE LOCAL_NAME LIKE 'ASIA%';

UPDATE BONUS
SET BONUS = 0.3
WHERE EMP_ID IN (SELECT EMP_ID
                 FROM EMP_SALARY
                      JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
                      JOIN LOCATION ON(LOCATION_ID = LOCAL_CODE)
                 WHERE LOCAL_NAME LIKE 'ASIA%');

COMMIT;

-- UPDATE시 변경할 값은 해당 컬럼에 대한 제약조건에 위배되지 않아야 함
UPDATE EMPLOYEE
SET DEPT_CODE = '65'
WHERE DEPT_CODE = 'D6';
-- 제약조건으로 연결되어 있지 않기 때문에 업데이트 잘 됨
-- 제약조건 생성하고 다시 해보면
-- 오류 보고 - ORA-02291: integrity constraint (KH.SYS_C007113) violated - parent key not found

ROLLBACK;

-- 제약조건 생성
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);
---------------------------------------

UPDATE DEPARTMENT
SET LOCATION_ID = '65'
WHERE LOCATION_ID = 'L2';

UPDATE EMPLOYEE
SET EMP_NAME = NULL
WHERE EMP_ID = 200;
-- NOT NULL 제약조건에 위배

COMMIT;

-- DELETE
SELECT * FROM EMPLOYEE;

DELETE FROM EMPLOYEE
WHERE EMP_NAME = '장채현';
-- 23개 행 출력

ROLLBACK; -- 24개 행 출력

DELETE FROM EMPLOYEE; -- 아무 행도 출력되지 않음, 위에 ROLLBACK통해서 되돌리기

DELETE FROM DEPARTMENT
WHERE DEPT_ID = 'D1';

-- 삭제 시 FOREIGN KEY제약 조건으로 컬럼 삭제가 불가능할 경우 제약조건을 비활성화 시킬 수 있음
ALTER TABLE EMPLOYEE
DISABLE CONSTRAINT SYS_C007113 CASCADE;

DELETE FROM DEPARTMENT
WHERE DEPT_ID = 'D1';

SELECT * FROM DEPARTMENT;
SELECT * FROM EMPLOYEE;

ROLLBACK;

ALTER TABLE EMPLOYEE
ENABLE CONSTRAINT SYS_C007113;

-- TRUNCATE :테이블 전체 행 삭제
-- ROLLBACK을 통해 복구 불가능
-- DELETE보다 수행 속도 빨라서 씀

COMMIT;

SELECT * FROM EMP_SALARY; -- 24개 행

DELETE FROM EMP_SALARY; -- 전체 삭제

ROLLBACK;

TRUNCATE TABLE EMP_SALARY; -- ROLLBACK